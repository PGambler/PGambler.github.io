                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              [{"title":"springIOC相关注册注解及接口","url":"/2020/11/24/e239fbf527a5/","content":"IOC作为spring的核心，有哪些相关的注解以及接口？借助网上的一篇文章特此做一份自己记录 深入学习Spring组件注册@Bean这是一个方法级别上的注解，主要用在@Configuration注解的类里，也可以在@component注解的类里@ComponentScan这是一个类级别上的注解，配合@Configuration注解一起使用。从定义扫描的路径（未指定即为当前注解类所在包）中找出标注@Controller、@Service、@Repository、@Component的类装配到spring容器中excludeFilters来排除一些组件的扫描：includeFilters的作用和excludeFilters相反，其指定的是哪些组件需要被扫描：@Scope组件的作用域，类与方法级别都可使用该注解。默认情况下IOC容器里面的组件均是单例（容器创建过程注入），可通过@Scope注解进行组件作用域配置：1） singleton：单实例（默认）,在Spring IOC容器启动的时候会调用方法创建对象然后纳入到IOC容器中，以后每次获取都是直接从IOC容器中获取（map.get()）；2）prototype：多实例，IOC容器启动的时候并不会去创建对象，而是在每次获取的时候才会去调用方法创建对象；3）request：一个请求对应一个实例；4）session：同一个会话对应一个实例；@Lazy懒加载是针对单例模式而言的，正如前面所说，IOC容器中的u组件默认是单例的，容器启动的时候会调用方法创建对象然后注入到IOC容器中。而当使用懒加载模式时，对象将不在容器启动过程中马上创建（除非使用），而是等到对象首次被调用时进行实例化注入容器并返回给调用方。Conditional条件注册注解，类与方法级别的注解，该注解可以指定组件注册的条件，当组件满足特定的条件后才注入IOC容器。该注解接受一个实现Condition接口的类型：Profile@Profile可以根据不同的环境变量来注册不同的组件Spring 中的@Profile 注解的作用是什么？@Import到目前为止，我们可以使用包扫描和@Bean来实现组件注册。除此之外，我们还可以使用@Import来快速地往IOC容器中添加组件。ImportSelector通过@Import我们已经实现了组件的导入，如果需要一次性导入较多组件，我们可以使用ImportSelector来实现。ImportBeanDefinitionRegistrar除了上面两种往IOC容器导入组件的方法外，我们还可以使用ImportBeanDefinitionRegistrar来手动往IOC容器导入组件。FactoryBeanSpring还提供了一个FactoryBean接口，我们可以通过实现该接口来注册组件，该接口包含了两个抽象方法和一个默认方法：以上有些是个人观点，如发现有误还望指出（完）","tags":["SPRING","IOC注解"],"categories":["后台","JAVA","学习","JAVA","SPRING"]},{"title":"前后端分离vue+springboot所遇到的跨域问题","url":"/2020/11/24/3bb86e27f71c/","content":"跨域这是我第二次遇到此问题，特此记录解决方法。跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。比如，站点 http://domain-a.com 的某 HTML 页面通过 出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。 （译者注：这段描述不准确，并不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。）跨域资源共享（CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 XMLHttpRequest 或Fetch）使用 CORS，以降低跨域 HTTP 请求所带来的风险。摘自：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS实现通过编写中间件（过滤器、适配器）这里我通过滤器实现：从该过滤器可看到，它将请求的响应体进行了部分设置，包括：Access-Control-Allow-Origin：访问源控制Access-Control-Allow-Credentials：是否返回cookieAccess-Control-Allow-Methods：处理发送请求方式Access-Control-Expose-Headers：允许暴露给前端的属性Access-Control-Allow-Headers：允许前端访问携带的属性通过Spring注解的方式为请求handler或controller添加@CrossOrigin允许跨源请求注解，默认允许所有的域以及允许所有的header。详见：https://docs.spring.io/spring/docs/4.2.7.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html","tags":["CORS","JAVA"],"categories":["后台","JAVA"]},{"title":"字符转换大字符","url":"/2020/11/24/f8afecf942d8/","content":"字符转换大字符平时使用其他架构或者其他项目中，在控制台或日志文件中会出现由多个字符组成项目的名称，看起来有点意思。但是我们平时开发项目想要这样打印项目名称时，会发现拼装繁琐，而且浪费时间。printBigChar能根据特定的规则得到我们想要的字符形状，目前支持26个字母（大小写）。大字符由多个特定字符组成形成特定的形状所代表的字符使用npm i print-big-char -savenode.js说明大字符结构一个大字符是由多个指定字符通过坐标组标记位置形成的形状，其占用列数由col_num指定、占用行数由position列表个数决定。position是一个二维数组，元素可以是数字以及字符串：如大字符“A”的定义：其中position[0][0]=&gt;4：表示该大字符第一行在拼装4个空格后再拼装1个指定字符；position[1][0]=&gt;3：表示该大字符第二行在拼装3个空格后再拼装1个指定字符；position[1][1]=&gt;1：表示该大字符第二行在已经拼装的字符串基础上再拼装1个空格之后再拼装1个指定字符；position[2][0]=&gt;”2(5)”：表示该大字符第三行在拼装2个空格后再拼装5个指定字符；…最后形成大字符：解析器解析定义的结构拼装成大字符，根据坐标组形成字符形状，确保大字符所占列数统一，然后得到的大字符字符组存储于对象print_list数组中。工厂工厂提供大字符结构的注册，大字符构建对象的创建，以及维护大字符构建对象的单例。工厂会根据某一映射规则将要形成大字符的字符映射到对象的构建结构上，然后创建对象并返回。当我们想要的字符在printBigChar中没有时，我们可以通过自定义大字符结构并注册到系统中，从而使用。注册（扩展）注意：所有大字符结构定义必须继承于BigChar以及以BigChar_开头，才能正确创建对象。（这里将会有一个问题，就是当需要定义像问号这样的符号时需要额外的映射器才能正确创建大字符对象）参数示例：打印间隙为4间隙填充为*号的大字符注意：空格将被解析为默认大字符打印成全由*号形成的大字符改变L的组成字符为=号打印全由*号形成的大字符，但L为=号此时参数中的字符定义优先级更高打印居中对齐的大字符（默认）打印顶点对齐的大字符打印底部对齐的大字符倾斜度（暂不支持）略扩展参考工厂注册优化目前仅支持26个字母的大写（小写也会转换为大写），后续会加入其他字符包括标点符号，也欢迎加入新的字符定义更新日志时间版本内容2019/12/261.1.5      集成mocha测试    集成webpack打包应用  2019/12/181.0.2      增加特殊字符支持，增加字符与定义结构映射表    修复新的打印引用旧的定义对象  免责声明本工具仅用于学习交流使用，禁止用于商业用途，使用本工具所造成的的后果由使用者承担！有疑问请 mail to: xfqing_mid@163.com","tags":["NODEJS","PRINTER","STRING"],"categories":["自建包","NODEJS"]},{"title":"一个mongoDB的CRUD模块","url":"/2020/11/24/e8db45d02017/","content":"概述本模块是针对mongoDB的CRUD操作进行封装的模块，你只需指定目标mongoDB的相关配置以及所操作的document，你将得到一个代理对象，为你提供mongoDB的相关操作，并支持日志记录.开始npm install –save handler4mongodb实例优化后续更新日志时间版本内容2020/03/051.0.1修复数据库会话提前关闭问题；CRUD改为批量操作；2020/01/131.0.0新增免责声明本工具仅用于学习交流使用，禁止用于商业用途，使用本工具所造成的的后果由使用者承担！ 有疑问请 mail to: &#120;&#102;&#113;&#105;&#110;&#103;&#x5f;&#x6d;&#x69;&#x64;&#64;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;","tags":["NOSQL","MONGODB","NODEJS","CRUD"],"categories":["NOSQL","MONGODB","自建包","NODEJS"]}]